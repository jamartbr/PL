\documentclass[12pt, spanish]{article}
\usepackage[spanish]{babel}
\selectlanguage{spanish}
%\usepackage{natbib}
\usepackage{url}
\usepackage[utf8x]{inputenc}
\usepackage{graphicx}
\graphicspath{{images/}}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{vmargin}
\usepackage{multirow}
\usepackage{float}
\usepackage{chngpage}

%Para poder hacer diagramas BNF en LaTeX
\usepackage{backnaur}
\usepackage{syntax}

\usepackage{amsfonts}

\usepackage{subcaption}

\usepackage{hyperref}
\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={4.0},
]{doclicense}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}

% para codigo
\usepackage{listings}
\usepackage{xcolor}



%% configuración de listings

\definecolor{listing-background}{HTML}{F7F7F7}
\definecolor{listing-rule}{HTML}{B3B2B3}
\definecolor{listing-numbers}{HTML}{B3B2B3}
\definecolor{listing-text-color}{HTML}{000000}
\definecolor{listing-keyword}{HTML}{435489}
\definecolor{listing-identifier}{HTML}{435489}
\definecolor{listing-string}{HTML}{00999A}
\definecolor{listing-comment}{HTML}{8E8E8E}
\definecolor{listing-javadoc-comment}{HTML}{006CA9}

\lstdefinestyle{eisvogel_listing_style}{
  language         = python,
%$if(listings-disable-line-numbers)$
%  xleftmargin      = 0.6em,
%  framexleftmargin = 0.4em,
%$else$
  numbers          = left,
  xleftmargin      = 0em,
 framexleftmargin = 0em,
%$endif$
  backgroundcolor  = \color{listing-background},
  basicstyle       = \color{listing-text-color}\small\ttfamily{}\linespread{1.15}, % print whole listing small
  breaklines       = true,
  frame            = single,
  framesep         = 0.19em,
  rulecolor        = \color{listing-rule},
  frameround       = ffff,
  tabsize          = 4,
  numberstyle      = \color{listing-numbers},
  aboveskip        = 1.0em,
  belowskip        = 0.1em,
  abovecaptionskip = 0em,
  belowcaptionskip = 1.0em,
  keywordstyle     = \color{listing-keyword}\bfseries,
  classoffset      = 0,
  sensitive        = true,
  identifierstyle  = \color{listing-identifier},
  commentstyle     = \color{listing-comment},
  morecomment      = [s][\color{listing-javadoc-comment}]{/**}{*/},
  stringstyle      = \color{listing-string},
  showstringspaces = false,
  escapeinside     = {/*@}{@*/}, % Allow LaTeX inside these special comments
  literate         =
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\'e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\EUR}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
  {…}{{\ldots}}1 {≥}{{>=}}1 {≤}{{<=}}1 {„}{{\glqq}}1 {“}{{\grqq}}1
  {”}{{''}}1
}
\lstset{style=eisvogel_listing_style}


\usepackage[default]{sourcesanspro}

\setmarginsrb{2 cm}{1 cm}{2 cm}{2 cm}{1 cm}{1.5 cm}{1 cm}{1.5 cm}

\title{Práctica 3. Grupo Viernes 3.\\
  \hspace{0.05cm} }
\author{Antonio David Villegas Yeguas\\
		Juan Emilio Martinez Manjon\\
		Alejandro Manzanares Lemus\\
		Najib Saadouli Arco}
\date{\today}

\renewcommand*\contentsname{hola}

\makeatletter
\let\thetitle\@title
\let\theauthor\@author
\let\thedate\@date
\makeatother

\pagestyle{fancy}
\fancyhf{}
\rhead{\theauthor}
\lhead{\thetitle}
\cfoot{\thepage}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}
    \centering
    \vspace*{0.3 cm}
    \includegraphics[scale = 0.50]{ugr.png}\\[0.7 cm]
    %\textsc{\LARGE Universidad de Granada}\\[2.0 cm]
    \textsc{\large 4º CSI 2020/21 - Grupo 2}\\[0.5 cm]
    \textsc{\large Grado en Ingeniería Informática}\\[0.5 cm]
    \rule{\linewidth}{0.2 mm} \\[0.2 cm]
    { \huge \bfseries \thetitle}\\
    \rule{\linewidth}{0.2 mm} \\[1 cm]

    \begin{minipage}{0.4\textwidth}
        \begin{flushleft} \large
            \emph{Autores:}\\
            \theauthor\\
            \end{flushleft}
            \end{minipage}~
            \begin{minipage}{0.4\textwidth}
            \begin{flushright} \large
            \emph{Asignatura: \\
            Procesadores de Lenguajes}   \\

        \end{flushright}
    \end{minipage}\\[0.5cm]

    {\large \thedate}\\[0.5cm]
    %{\url{https://github.com/advy99/AA/}}
    {\doclicenseThis}

    \vfill

\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Introducción: Descripción del lenguaje asignado.}

Esta práctica tratará sobre el desarrollo de un lenguaje de programación estructurado. Este lenguaje utilizará identificadores que deberán ser declarados antes de ser utilizados y tendrá como tipos de datos mínimos los tipos \texttt{entero}, \texttt{real}, \texttt{caracter} y \texttt{booleano}.

Para los tipos de datos \texttt{entero} y \texttt{real} podremos realizar las operaciones de suma, resta, producto, división y operadores de relación, mientras que para el tipo de dato \texttt{booleano} podremos realizar la operación and, or, not y xor.

El lenguaje poseerá la sentencia de asignación para todos los tipos de expresiones, además de permitir las expresiones aritméticas lógicas, además de estructuras de control básicas (\texttt{if-then-else} y \texttt{while}).

Dispondrá de una sentencia de entrada y otra de salida en la que utilizará el teclado y la salida de terminal respectivamente. La sentencia de entrada deberá permitir leer sobre una lista de identificadores y la de salida debe permitir escribir una lista de expresiones y/o constantes de tipo cadena. Estas sentencias no representarán una llamada a un subprograma.

El lenguaje asignado (BAAAC) añade también las siguientes características:

\begin{itemize}
	\item Sintaxis inspirada en C.
	\item Palabras reservadas en castellano.
	\item Listas como estructura de datos como tipo elemental. Deben considerarse las constantes de tipo lista.
	\item Funciones como subprogramas.
	\item Repeat-until como estructura de control.
\end{itemize}

\newpage

\section{Descripción de formal de la sintaxis del lenguaje usando BNF.}

\vspace{5 mm}

La sintaxis usando BNF y añadiendo las consideraciones correspondiente al lenguaje \textbf{BAAAC} sería:

\begin{bnf*}
	\bnfprod{Programa}
		{\bnfpn{Cabecera\_programa} \bnfsp \bnfpn{bloque}}\\
	\bnfprod{Cabecera\_programa}
    	{ principal() }\\
  \bnfprod{bloque}
		{\bnfpn{Inicio\_de\_bloque}}\\
		\bnfmore{\bnfsp \bnfpn{Declar\_de\_variables\_locales}}\\
		\bnfmore{\bnfsp \bnfpn{Declar\_de\_subprogs}}\\
		\bnfmore{\bnfsp \bnfpn{Sentencias}}\\
		\bnfmore{\bnfsp \bnfpn{Fin\_de\_bloque}}\\
	\bnfprod{Inicio\_de\_bloque}
    	{ \{ }\\
	\bnfprod{Fin\_de\_bloque}
    	{ \} }\\
	\bnfprod{Declar\_de\_variables\_locales}
		{\bnfpn{Declar\_de\_variables\_locales} \bnfsp \bnfpn{Cuerpo\_declar\_variables}}\\
		\bnfmore{| \bnfsp \bnfpn{Cuerpo\_declar\_variables}}\\
		\bnfmore{| \bnfsp \epsilon}\\
	\bnfprod{Cuerpo\_declar\_variables}
		{variable \bnfsp \bnfpn{tipo} \bnfsp \bnfpn{ident\_variables} ;}\\
	\bnfprod{ident\_variables}
    {\bnfpn{ident\_variables} \bnfsp  ,  \bnfsp \bnfpn{identificador}}\\
    \bnfmore{| \bnfsp \bnfpn{ident\_variables} \bnfsp , \bnfsp \bnfpn{identificador} \bnfsp = \bnfsp \bnfpn{expresion}}\\
\bnfmore{| \bnfsp \bnfpn{identificador}}\\
\bnfmore{| \bnfsp \bnfpn{identificador} \bnfsp = \bnfsp \bnfpn{expresion}}\\
	\bnfprod{Declar\_de\_subprogs}
    {\bnfpn{Declar\_de\_subprogs} \bnfsp \bnfpn{Declar\_subprog}}\\
    \bnfmore{| \bnfsp \epsilon}\\
  \bnfprod{Declar\_subprog}
    {\bnfpn{Cabecera\_subprograma} \bnfsp \bnfpn{bloque}}\\
  \bnfprod{Cabecera\_subprograma}
	 { \bnfpn{tipo} \bnfsp \bnfpn{identificador} \bnfsp ( \bnfpn{parametros} ) }\\
  \bnfprod{parametros}
    {\bnfpn{parametro}}\\
	 \bnfmore{| \bnfsp \bnfpn{parametro\_preced} \bnfsp \bnfpn{parametro}}\\
    \bnfmore{| \bnfsp \epsilon}\\
  \bnfprod{parametro\_preced}
	 {\bnfpn{parametro\_preced} \bnfsp \bnfpn{parametro\_preced} }\\
	 \bnfmore{| \bnfsp \bnfpn{parametro} \bnfsp ,}\\
  \bnfprod{parametro}
    {\bnfpn{tipo} \bnfsp \bnfpn{identificador}}\\
  \bnfprod{tipo}
	 	{\bnfpn{tipo\_basico}}\\
		\bnfmore{| \bnfsp  lista de   \bnfsp \bnfpn{tipo\_basico}}\\
	\bnfprod{tipo\_basico}
    {\bnfpn{entero}}\\
    \bnfmore{| \bnfsp \bnfpn{real}}\\
    \bnfmore{| \bnfsp \bnfpn{caracter}}\\
    \bnfmore{| \bnfsp \bnfpn{booleano}}\\
	\bnfprod{Sentencias}
		{\bnfpn{Sentencias} \bnfsp \bnfpn{Sentencia}}\\
		\bnfmore{| \bnfsp \epsilon}\\
	\bnfprod{Sentencia}
		{\bnfpn{bloque}}\\
		\bnfmore{| \bnfsp \bnfpn{sentencia\_asignacion}}\\
		\bnfmore{| \bnfsp \bnfpn{sentencia\_if}}\\
		\bnfmore{| \bnfsp \bnfpn{sentencia\_while}}\\
		\bnfmore{| \bnfsp \bnfpn{sentencia\_repeat\_until}}\\
    \bnfmore{| \bnfsp \bnfpn{sentencia\_return}}\\
    \bnfmore{| \bnfsp \bnfpn{sentencia\_avanzar}}\\
    \bnfmore{| \bnfsp \bnfpn{sentencia\_retroceder}}\\
    \bnfmore{| \bnfsp \bnfpn{sentencia\_cursor\_comienzo}}\\
    \bnfmore{| \bnfsp \bnfpn{sentencia\_entrada}}\\
    \bnfmore{| \bnfsp \bnfpn{sentencia\_salida}}\\
	\bnfprod{sentencia\_asignacion}
		{\bnfpn{identificador} \bnfsp = \bnfsp \bnfpn{expresion} \bnfsp  ; }\\
	\bnfprod{sentencia\_if}
		{ si  \bnfsp \bnfpn{expresion} \bnfsp \bnfpn{Sentencia}}\\
		\bnfmore{ \bnfsp [ sino  \bnfpn{Sentencia}]}\\
	\bnfprod{sentencia\_while}
		{ mientras  \bnfsp \bnfpn{expresion} \bnfsp \bnfpn{Sentencia}}\\
  \bnfprod{sentencia\_repeat\_until}
    { repetir  \bnfsp \bnfpn{Sentencia} \bnfsp  mientras  \bnfsp ( \bnfpn{expresion} \bnfsp ) ; }\\
  \bnfprod{sentencia\_return}
    { devuelve  \bnfsp \bnfpn{identificador} \bnfsp ;}\\
  \bnfprod{sentencia\_avanzar}
    {\bnfpn{identificador} \bnfsp  >>  ;}\\
  \bnfprod{sentencia\_retroceder}
    {\bnfpn{identificador} \bnfsp  <<  ;}\\
  \bnfprod{sentencia\_cursor\_comienzo}
    { \$  \bnfsp \bnfpn{identificador} \bnfsp ;}\\
  \bnfprod{sentencia\_entrada}
    { entrada  \bnfsp \bnfpn{lista\_variables}}\\
  \bnfprod{lista\_variables}
    {\bnfpn{lista\_variables}  ,  \bnfpn{identificador}}\\
    \bnfmore{| \bnfsp \bnfpn{identificador}}\\
  \bnfprod{sentencia\_salida}
    { salida  \bnfsp \bnfpn{lista\_expresiones\_o\_cadena}}\\
  \bnfprod{lista\_expresiones\_o\_cadena}
    {\bnfpn{lista\_expresiones\_o\_cadena} \bnfsp  ,  \bnfsp \bnfpn{cadena}}\\
    \bnfmore{| \bnfsp \bnfpn{expresion} \bnfsp  ,  \bnfsp \bnfpn{lista\_expresiones\_o\_cadena}}\\
    \bnfmore{| \bnfsp \bnfpn{cadena}}\\
    \bnfmore{| \bnfsp \bnfpn{expresion}}\\
  \bnfprod{cadena}
	 { " \bnfpn{secuencia\_caract}  " }\\
  \bnfprod{secuencia\_caract}
    {\bnfpn{secuencia\_caract} \bnfsp \bnfpn{caracter}}\\
    \bnfmore{| \bnfsp \epsilon}\\
	\bnfprod{expresion}
		{ ( \bnfpn{expresion} ) }\\
		\bnfmore{| \bnfsp \bnfpn{op\_unario} \bnfsp \bnfpn{expresion}}\\
		\bnfmore{| \bnfsp \bnfpn{expresion} \bnfsp \bnfpn{op\_binario} \bnfsp \bnfpn{expresion}}\\
    \bnfmore{| \bnfsp \bnfpn{expresion} \bnfsp \bnfpn{op\_ternario\_prim} \bnfsp}\\
	 \bnfmore{\bnfpn{expresion} \bnfsp \bnfpn{op\_ternario\_seg} \bnfsp \bnfpn{expresion}}\\
    \bnfmore{| \bnfsp - \bnfsp \bnfpn{expresion}}\\
    \bnfmore{| \bnfsp \bnfpn{llamada\_subprograma}}\\
		\bnfmore{| \bnfsp \bnfpn{identificador}}\\
		\bnfmore{| \bnfsp \bnfpn{constante}}\\
	\bnfprod{op\_ternario\_prim}
    {++}\\
  \bnfprod{op\_ternario\_seg}
    {@}\\
  \bnfprod{op\_binario}
    {+ \bnfsp | \bnfsp - \bnfsp | \bnfsp * \bnfsp | \bnfsp /}\\
    \bnfmore{| \bnfsp < \bnfsp | \bnfsp <= \bnfsp | \bnfsp > \bnfsp | \bnfsp >= \bnfsp | \bnfsp == \bnfsp | \bnfsp != \bnfsp}\\
    \bnfmore{| \bnfsp \&\& \bnfsp | \bnfsp \texttt{||} \bnfsp | \bnfsp \wedge  }\\
    \bnfmore{| \bnfsp @ \bnfsp | \bnfsp -- \bnfsp | \bnfsp \% \bnfsp | \bnfsp **}\\
  \bnfprod{op\_unario}
    { - \bnfsp | \bnfsp ! \bnfsp | \bnfsp \# \bnfsp | \bnfsp ?}\\
  \bnfprod{llamada\_subprograma}
    { \bnfpn{identificador} \bnfsp  ( \bnfsp \bnfpn{lista\_const} \bnfsp ) \bnfsp ;}\\
  \bnfprod{lista_const}
    {\bnfpn{constante}}\\
	 \bnfmore{| \bnfsp \bnfpn{lista_const_prec} \bnfsp \bnfpn{constante}}\\
    \bnfmore{| \bnfsp \epsilon}\\
  \bnfprod{lista_const_prec}
  	 {\bnfpn{lista_const_prec} \bnfsp \bnfpn{lista_const_prec}}\\
    \bnfmore{| \bnfsp \bnfpn{constante} \bnfsp , }\\
    \bnfmore{| \bnfsp \epsilon}\\
  \bnfprod{identificador}
		{ \bnfpn{letra} \bnfsp \bnfpn{resto\_identificador}}\\
  \bnfprod{resto\_identificador}
    { \bnfpn{resto\_identificador} \bnfsp \bnfpn{letra}}\\
    \bnfmore{| \bnfsp \bnfpn{digito} \bnfsp \bnfpn{resto\_identificador}}\\
	 \bnfmore{| \bnfsp \epsilon}\\
  \bnfprod{constante}
    {\bnfpn{constante\_basica}}\\
    \bnfmore{| \bnfsp {Inicio\_de\_bloque} \bnfsp \bnfpn{contenido\_lista} \bnfsp {Fin\_de\_bloque}}\\
  \bnfprod{constante\_basica}
    {\bnfpn{entero}}\\
    \bnfmore{| \bnfsp \bnfpn{real}}\\
    \bnfmore{| \bnfsp \bnfpn{caracter}}\\
    \bnfmore{| \bnfsp \bnfpn{booleano}}\\
  \bnfprod{lista}
    { [  \bnfpn{contenido\_lista}  ] }\\
  \bnfprod{contenido\_lista}
    {\bnfpn{contenido\_lista\_preced} \bnfsp \bnfpn{constante\_basica}}\\
	 \bnfmore{| \bnfsp \bnfpn{constante\_basica}}\\
    \bnfmore{| \bnfsp \epsilon}\\
  \bnfprod{contenido\_lista\_preced}
  	 {\bnfpn{contenido\_lista\_preced} \bnfsp \bnfpn{constante\_basica} \bnfsp ,}\\
	 \bnfmore{| \bnfpn{constante\_basica} \bnfsp ,}\\
	\bnfprod{entero}
    {\bnfpn{entero} \bnfpn{digito}}\\
    \bnfmore{| \bnfsp \bnfpn{digito}}\\
  \bnfprod{real}
		{\bnfpn{entero}.\bnfpn{entero}}\\
  \bnfprod{caracter}
        {Simbolo ASCII}\\
	\bnfprod{booleano}
		{  verdadero  |  falso  }\\
	\bnfprod{digito}
		{\bnfpn{ 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 }}\\
	\bnfprod{letra}
		{''a'' \bnfsp | \bnfsp ''b'' \bnfsp | \bnfsp ... \bnfsp | \bnfsp ''z''}\\
		\bnfmore{| \bnfsp ''A'' \bnfsp | \bnfsp ''B'' \bnfsp | \bnfsp ... \bnfsp | \bnfsp ''Z'' }\\
\end{bnf*}


\section{Definición de la semántica en lenguaje natural.}

Tras la definición formal de la sintaxis del lenguaje utilizando BNF, en este apartado describiremos con lenguaje natural la estructura del lenguaje.


\subsection{Sección principal.}

% Comentar que comenzamos con principal y un bloque, y de que esta compuesto un bloque
Nuestro programa comenzará con una cabecera de programa seguida de un bloque. La cabecera de programa, en nuestro caso, será la cadena ''principal()''.

Tras esta cadena le sigue un bloque, que en nuestro caso está delimitado por un inicio de bloque y un fin de bloque, que serán respectivamente ''\{'' y ''\}''. Dentro de cada bloque existirán tres secciones más distinguidas:

\begin{enumerate}
	\item Declaración de variables locales.
	\item Declaración de subprogramas.
	\item Sentencias.
\end{enumerate}

Cada una de estas secciones se desarrollan a partir de distintas reglas que podemos observar en el BNF, y que explicaremos en las siguientes secciones.

\subsection{Declaración de variables}

La declaración de variables se hace según las producciones de \texttt{<Declar_de_variables_locales>} donde vemos que las variables se declaran siguiendo las producciones de \texttt{<Cuerpo_declar_variables>}.


Para declarar una o varias variables es necesario especificar su ''tipo'', uno o varios ''identificadores'' y un punto y coma ('';''). Se crean tantas variables como identificadores pongamos.


Los identificadores son combinaciones alfanuméricas que deben empezar siempre por una letra. En la declaración de variables deben ir después del ''tipo'', separados por comas. Se da la opción de inicializar alguna de las variables asignándole una expresión con el símbolo ''='' a su identificador.

\subsubsection{Tipos de datos}

\begin{itemize}

	\item entero: Un numero entero entre 0 y 9.
	\item real: Un entero separado de otro entero por un punto (''.'')
	\item caracter: Cualquier elemento que pertenezca a la tabla ASCII.
	\item booleano: Puede ser o la cadena ''verdadero'' o la cadena ''falso''.
	\item listade <tipo_basico> : Es una lista formada por datos cuyo tipo viene en <tipo_basico>. Esos tipos son los cuatro explicados anteriormente.
\end{itemize}

\subsection{Declaración de subprogramas: Funciones}

En nuestro caso, debido al lenguaje asignado, los subprogramas serán funciones.

Para declarar una función existe una regla \texttt{<Declar_de_subprogs>} que sus posibles producciones son, la declaración de una función seguido de la declaración de la propia función, de forma que podamos declarar varias funciones y no solo una, o la cadena vacia, de forma que podamos no parar de declarar un subprograma o no declarar ninguno.

Para declarar el cuerpo de una función tenemos la regla \texttt{<Declar\_subprog>}, la cuál produce la cabecera de la función seguida de un bloque.

La cabecera de la función es generáda por \texttt{<Cabecera\_subprograma>} y será un tipo (el tipo de la variable que devolverá la función), este tipo es opcional ya que pueden existir funciones que no devuelvan nada, seguido de un identificador que servirá como nombre de la función y por último una serie de parámetros entre paréntesis.

Estos parámetros se generan con la regla \texttt{<parametros>}, que se trata de un parámetro, predecido de una coma y más parámetros, o un único parámetro, generádo con la regla \texttt{<parametro>}.

La regla parámetro a su vez nos genéra la estructura de un único parámetro, que está formada por el tipo y el identificador de dicho parámetro.

\subsection{Sentencias}

La declaración de sentencias comienza en la produccion \texttt{Sentencias} que nos permite generar todas las posibles sentencias que necesitemos.

Las posibles sentencias que podemos generar son:

\begin{itemize}
    \item{Sentencias de asignacion}
    \item{Sentencias if}
    \item{Sentencias while}
    \item{Sentencias return}
    \item{Sentencias de entrada}
    \item{Sentencias de salida}
\end{itemize}

Por las caracteristicas del lenguaje asiganado se nos pide añadir la sentencia de tipo repeat-until. Esta sentencia consiste en repetir una sentencia determinada mientras se cumpla una expresión. Generamos esta sentencia a través de la regla \texttt{<sentencia\_repeat\_until>}.

Además, debido a que nuestro lenguaje trabaja con el tipo de dato lista, debemos añadir tres sentencias adicionales:

\begin{itemize}
    \item{Sentencia avanzar}: La sentencia avanzar se genera a través de la regla \texttt{<sentencia\_avanzar>} y consiste en aplicar el operador ''$>>$'' a una lista, para que el cursor avance una posición.
    \item{Sentencia retroceder}: Esta sentencia se genera mediante la regla \texttt{<sentencia\_retroceder>} y consiste en aplicar el operador ''$<<$'' a una lista, para que el cursos retroceda una posición.
    \item{Sentencia cursor comienzo}: Finalmente la sentencia cursor comienzo consiste en aplicar el operador ''\$'' a una lista para que el cursor vuelva a la posición inicial. Esta sentencia se genera mendiante la regla \texttt{<sentencia_cursor_comienzo>}.
\end{itemize}

\section{Identificación de los tokens con el máximo nivel de abstracción.}

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
\begin{table}[h]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Token} & \textbf{Identificador} & \textbf{Atributos} & \textbf{Patrón} \\ \hline
CONSTANTE\_BASICA & 257 & 0: entero, 1:real, 2:caracter, 3:booleano  & (``{[}a-zA-Z{]}'' | {[}0-9{]}+ | {[}0-9{]}+``.''{[}0-9{]}+ | ``verdadero'' | ``falso'') \\ \hline
CORCHETE\_ABRE & 258 &  & ``{[}'' \\ \hline
CORCHETE\_CIERRA & 259 &  & ``{]}'' \\ \hline
COMA & 260 &  & ``,'' \\ \hline
OP\_EXC\_BIN & 261 & 0:+, 1:*, 2:/, 3:\&\&, 4:||, 5:\textasciicircum{}, 6:\textless{}, 7:\textless{}=, 8:\textgreater{}, 9:\textgreater{}=, 10:==, 11:!=, 12:--, 13:\%, 14:** & (``+'' | ``*'' | ``/'' | ``\&\&'' | ``||'' | ``\textasciicircum{}'' | ``\textless{}'' | ``\textgreater{}'' | ``\textless{}='' | ``\textgreater{}='' | ``=='' | ``!='' | ``--'' | ``\%'' | ``**'') \\ \hline
MENOS & 262 &  & ``-'' \\ \hline
OP\_EXC\_UN & 263 & 0:!, 1:\#, 2:? & (`` ! '' | ``\#'' | `` ?'') \\ \hline
ARROBA & 264 &  & ``@'' \\ \hline
MASMAS & 265 &  & ``++'' \\ \hline
ID & 266 &  & ``{[}a-zA-Z{]}+{[}a-zA-Z0-9{]}*'' \\ \hline
PYC & 267 &  & ``;'' \\ \hline
PARENTESIS\_ABRE & 268 &  & ``('' \\ \hline
PARENTESIS\_CIERRA & 269 &  & ``)'' \\ \hline
COMILLAS & 270 &  & `` '' '' \\ \hline
DOLAR & 271 &  & ``\$'' \\ \hline
AVANZAR & 272 &  & ``\textgreater{}\textgreater{}'' \\ \hline
RETROCEDER & 273 &  & ``\textless{}\textless{}'' \\ \hline
ENTRADA & 274 &  & ``entrada'' \\ \hline
SALIDA & 275 &  & ``salida'' \\ \hline
MIENTRAS & 276 &  & ``mientras'' \\ \hline
REPETIR & 277 &  & ``repetir'' \\ \hline
DEVUELVE & 278 &  & ``devuelve'' \\ \hline
SI & 279 &  & ``si'' \\ \hline
SINO & 280 &  & ``sino'' \\ \hline
ASIGNACION & 281 &  & ``='' \\ \hline
LISTADE & 282 &  & ``listade'' \\ \hline
LLAVE\_ABRE & 283 &  & ``\}'' \\ \hline
LLAVE\_CIERRA & 284 &  & ``\{'' \\ \hline
TIPO\_BASICO & 285 & 0: entero, 1:real, 2:caracter, 3:booleano & (``entero'' | ``real'' | ``caracter'' | ``booleano'') \\ \hline
VAR & 286 &  & ``variable'' \\ \hline
PRINCIPAL & 287 &  & ``principal()'' \\ \hline
CADENA & 288 & & `` ''{[}a-zA-Z0-9{]}*'' '' \\ \hline
\end{tabular}%
}
\end{table}


\end{document}
